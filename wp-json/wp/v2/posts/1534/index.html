{"id":1534,"date":"2022-03-10T07:21:29","date_gmt":"2022-03-10T07:21:29","guid":{"rendered":"http:\/\/localhost\/wordpress\/solid-principles-explained-dev-community\/"},"modified":"2022-03-10T07:21:29","modified_gmt":"2022-03-10T07:21:29","slug":"solid-principles-explained-dev-community","status":"publish","type":"post","link":"http:\/\/localhost\/wordpress\/solid-principles-explained-dev-community\/","title":{"rendered":"SOLID principles explained &#8211; DEV Community"},"content":{"rendered":"<p> <br \/>\n<\/p>\n<div data-article-id=\"1017839\" id=\"article-body\">\n<p>The SOLID principles are a set of good practices of the Object-Oriented Design (OOD) world. We should have them in consideration when producing our software if we want it to be more easily scalable, maintainable, and extended.<\/p>\n<p>SOLID is an acronym, and each character of this acronym refers to an OOD principle, explained down below.<\/p>\n<hr\/>\n<p><strong><em>S<\/em><\/strong> &#8211; Single Responsibility Principle<\/p>\n<p>One class should have only one responsibility. Sometimes you can see this principle written as &#8220;One class should only have one reason to change&#8221;. All of this means that a class should only do one job, and do it right!<\/p>\n<p>Let&#8217;s take a look at a small coding example.<\/p>\n<p>Say we have a class responsible for managing our users, whose code can be seen below.<\/p>\n<div class=\"highlight js-code-highlight\">\n<pre class=\"highlight plaintext\"><code>public class User {\n    private String name;\n    private int age;\n\n    public User(int name, int age){\n        this.name = name;\n        this.age = age;\n    }\n\n    public void saveUserToDatabase(){\n        \/\/implementation detail\n    }\n\n    \/\/getters and setters\n    ...\n}\n<\/code><\/pre>\n<div class=\"highlight__panel js-actions-panel\">\n<div class=\"highlight__panel-action js-fullscreen-code-action\">\n    <svg xmlns=\"http:\/\/www.w3.org\/2000\/svg\" width=\"20px\" height=\"20px\" viewbox=\"0 0 24 24\" class=\"highlight-action crayons-icon highlight-action--fullscreen-on\"><title>Enter fullscreen mode<\/title>\n    <path d=\"M16 3h6v6h-2V5h-4V3zM2 3h6v2H4v4H2V3zm18 16v-4h2v6h-6v-2h4zM4 19h4v2H2v-6h2v4z\"\/>\n<\/svg><\/p>\n<p>    <svg xmlns=\"http:\/\/www.w3.org\/2000\/svg\" width=\"20px\" height=\"20px\" viewbox=\"0 0 24 24\" class=\"highlight-action crayons-icon highlight-action--fullscreen-off\"><title>Exit fullscreen mode<\/title>\n    <path d=\"M18 7h4v2h-6V3h2v4zM8 9H2V7h4V3h2v6zm10 8v4h-2v-6h6v2h-4zM8 15v6H6v-4H2v-2h6z\"\/>\n<\/svg><\/p>\n<\/div>\n<\/div>\n<\/div>\n<p>As you can see from the above code, besides having the basic getters and setters, this class is also responsible for saving the user in the database.<\/p>\n<p>The previous class, being a data container, should only change if changes in our data model occur. With our current class that doesn&#8217;t happen, because we have a second reason to change. Every time we want to change the database logic, we will have to change our class, and that breaks the Single Responsibility Principle.<\/p>\n<p>The code below shows an example of the refactor we needed to do to have obedience to this principle.<\/p>\n<div class=\"highlight js-code-highlight\">\n<pre class=\"highlight plaintext\"><code>public class User {\n    private String name;\n    private int age;\n    private InfoPersistenseProvider database;\n\n    public User(int name, int age, InfoPersistenseProvider database){\n        this.name = name;\n        this.age = age;\n        this.database = database;\n    }\n\n    public void saveUserToDatabase(){\n        this.database.saveToDatabase();\n    }\n\n    \/\/getters and setters\n    ...\n}\n\npublic class InfoPersistenseProvider{\n\n    public InfoPersistenseProvider(){}\n\n    public void saveToDatabase(User user){\n        \/\/implementation detail\n    }\n\n    \/\/getters and setters\n    ...\n}\n<\/code><\/pre>\n<div class=\"highlight__panel js-actions-panel\">\n<div class=\"highlight__panel-action js-fullscreen-code-action\">\n    <svg xmlns=\"http:\/\/www.w3.org\/2000\/svg\" width=\"20px\" height=\"20px\" viewbox=\"0 0 24 24\" class=\"highlight-action crayons-icon highlight-action--fullscreen-on\"><title>Enter fullscreen mode<\/title>\n    <path d=\"M16 3h6v6h-2V5h-4V3zM2 3h6v2H4v4H2V3zm18 16v-4h2v6h-6v-2h4zM4 19h4v2H2v-6h2v4z\"\/>\n<\/svg><\/p>\n<p>    <svg xmlns=\"http:\/\/www.w3.org\/2000\/svg\" width=\"20px\" height=\"20px\" viewbox=\"0 0 24 24\" class=\"highlight-action crayons-icon highlight-action--fullscreen-off\"><title>Exit fullscreen mode<\/title>\n    <path d=\"M18 7h4v2h-6V3h2v4zM8 9H2V7h4V3h2v6zm10 8v4h-2v-6h6v2h-4zM8 15v6H6v-4H2v-2h6z\"\/>\n<\/svg><\/p>\n<\/div>\n<\/div>\n<\/div>\n<p>As you can see from the previous code example, what we did was remove the database logic to a separated class. <br \/>Let&#8217;s resume the example of changing the database type logic. Instead of changing the User class code, we only change the class that holds such logic, which in our case is the InfoPersistenseProvider class. If tomorrow we wanted to change such logic as well, we would only change in the proper place, which would always comply with the Single Responsibility Principle.<\/p>\n<hr\/>\n<p><strong><em>O<\/em><\/strong> &#8211; Open\/Closed Principle<\/p>\n<p>A class should be open for extension but closed for modifications. This means that we can add new functionalities without changing the existing code of the &#8220;base&#8221; class (that was extended).<\/p>\n<p>Now let&#8217;s take a look at a small coding example below, where we compute the user&#8217;s interest in a specific video content, based on its previous consumption habits, for example.<\/p>\n<div class=\"highlight js-code-highlight\">\n<pre class=\"highlight plaintext\"><code>public class Video{\n    private String type;\n\n    \/\/...\n\n    public double computeUserInterest(){\n        if(this.type.equals(\"Movie\")){\n            \/\/compute movie interest\n        }else if(this.type.equals(\"TVShow\")){\n            \/\/compute TVShow interest\n        }\n    }\n}\n<\/code><\/pre>\n<div class=\"highlight__panel js-actions-panel\">\n<div class=\"highlight__panel-action js-fullscreen-code-action\">\n    <svg xmlns=\"http:\/\/www.w3.org\/2000\/svg\" width=\"20px\" height=\"20px\" viewbox=\"0 0 24 24\" class=\"highlight-action crayons-icon highlight-action--fullscreen-on\"><title>Enter fullscreen mode<\/title>\n    <path d=\"M16 3h6v6h-2V5h-4V3zM2 3h6v2H4v4H2V3zm18 16v-4h2v6h-6v-2h4zM4 19h4v2H2v-6h2v4z\"\/>\n<\/svg><\/p>\n<p>    <svg xmlns=\"http:\/\/www.w3.org\/2000\/svg\" width=\"20px\" height=\"20px\" viewbox=\"0 0 24 24\" class=\"highlight-action crayons-icon highlight-action--fullscreen-off\"><title>Exit fullscreen mode<\/title>\n    <path d=\"M18 7h4v2h-6V3h2v4zM8 9H2V7h4V3h2v6zm10 8v4h-2v-6h6v2h-4zM8 15v6H6v-4H2v-2h6z\"\/>\n<\/svg><\/p>\n<\/div>\n<\/div>\n<\/div>\n<p>What happens if you want to add 10 new video types to our platform? Our if-else would become gigantic. This example, where we constantly add if blocks, represents a classic example of the violation of the Open\/Closed principle.<\/p>\n<p>How can we obey to this principle?<br \/>In the code block below we show how.<\/p>\n<div class=\"highlight js-code-highlight\">\n<pre class=\"highlight plaintext\"><code>public interface Video{\n    public double computeUserInterest();\n}\n\npublic class Movie implements Video{\n    public double computeUserInterest(){\n        \/\/implementation detail\n    }\n}\n\npublic class TVShow implements Video{\n    public double computeUserInterest(){\n        \/\/implementation detail\n    }\n}\n<\/code><\/pre>\n<div class=\"highlight__panel js-actions-panel\">\n<div class=\"highlight__panel-action js-fullscreen-code-action\">\n    <svg xmlns=\"http:\/\/www.w3.org\/2000\/svg\" width=\"20px\" height=\"20px\" viewbox=\"0 0 24 24\" class=\"highlight-action crayons-icon highlight-action--fullscreen-on\"><title>Enter fullscreen mode<\/title>\n    <path d=\"M16 3h6v6h-2V5h-4V3zM2 3h6v2H4v4H2V3zm18 16v-4h2v6h-6v-2h4zM4 19h4v2H2v-6h2v4z\"\/>\n<\/svg><\/p>\n<p>    <svg xmlns=\"http:\/\/www.w3.org\/2000\/svg\" width=\"20px\" height=\"20px\" viewbox=\"0 0 24 24\" class=\"highlight-action crayons-icon highlight-action--fullscreen-off\"><title>Exit fullscreen mode<\/title>\n    <path d=\"M18 7h4v2h-6V3h2v4zM8 9H2V7h4V3h2v6zm10 8v4h-2v-6h6v2h-4zM8 15v6H6v-4H2v-2h6z\"\/>\n<\/svg><\/p>\n<\/div>\n<\/div>\n<\/div>\n<h2>\n  <a name=\"now-what-happens-if-you-want-to-add-a-new-video-type-to-our-platform-you-just-need-to-make-the-class-implement-our-interface-this-makes-our-code-cleaner-and-more-important-obeying-to-the-openclose-principle\" href=\"#now-what-happens-if-you-want-to-add-a-new-video-type-to-our-platform-you-just-need-to-make-the-class-implement-our-interface-this-makes-our-code-cleaner-and-more-important-obeying-to-the-openclose-principle\"><br \/>\n  <\/a><br \/>\n  Now, what happens if you want to add a new video type to our platform? You just need to make the class implement our interface. This makes our code cleaner and, more important, obeying to the Open\/Close principle.<br \/>\n<\/h2>\n<p><strong><em>L<\/em><\/strong> &#8211; Liskov Substitution Principle<\/p>\n<p>In practical terms, this principle states that if you have a parent class and one of its subclasses, you can replace the parent class by the subclass and still have valid behavior. This is the basic behavior we find in the OOP principle <strong>inheritance<\/strong>, meaning the subclass should be able to do everything its parent class does.<\/p>\n<p>Let&#8217;s analyze the upcoming block of code to understand this concept better!<\/p>\n<div class=\"highlight js-code-highlight\">\n<pre class=\"highlight plaintext\"><code>public class Movie{\n    public void play(){\n        \/\/implementation detail\n    }\n\n    public void increaseVolume(){\n        \/\/implementation detail\n    }\n}\n\npublic class Joker extends Movie{\n\n}\n\npublic class ASilentMovie extends Movie{\n    @Override\n    public void increaseVolume(){}\n}\n<\/code><\/pre>\n<div class=\"highlight__panel js-actions-panel\">\n<div class=\"highlight__panel-action js-fullscreen-code-action\">\n    <svg xmlns=\"http:\/\/www.w3.org\/2000\/svg\" width=\"20px\" height=\"20px\" viewbox=\"0 0 24 24\" class=\"highlight-action crayons-icon highlight-action--fullscreen-on\"><title>Enter fullscreen mode<\/title>\n    <path d=\"M16 3h6v6h-2V5h-4V3zM2 3h6v2H4v4H2V3zm18 16v-4h2v6h-6v-2h4zM4 19h4v2H2v-6h2v4z\"\/>\n<\/svg><\/p>\n<p>    <svg xmlns=\"http:\/\/www.w3.org\/2000\/svg\" width=\"20px\" height=\"20px\" viewbox=\"0 0 24 24\" class=\"highlight-action crayons-icon highlight-action--fullscreen-off\"><title>Exit fullscreen mode<\/title>\n    <path d=\"M18 7h4v2h-6V3h2v4zM8 9H2V7h4V3h2v6zm10 8v4h-2v-6h6v2h-4zM8 15v6H6v-4H2v-2h6z\"\/>\n<\/svg><\/p>\n<\/div>\n<\/div>\n<\/div>\n<p>Let&#8217;s say we have our Movie superclass, which has two main actions: play (which starts the movie) and increaseVolume (which increases the movie&#8217;s volume). This logic will work in most of the movies produced in today&#8217;s day and age, but there is a market niche for silent movies which, as we all know, do not have any volume. <\/p>\n<p>Do we have a correct behavior if, all of sudden, in our code we replaced a Movie object with another object that represents a silent movie? The answer is NO. No, because of the increaseVolume action. It is not correct to say &#8220;I will increase the volume of a silent movie&#8221;, because there is no such thing as the concept of volume in these kinds of movies! This means that we don&#8217;t obey the Liskov Substitution Principle.<\/p>\n<hr\/>\n<p><strong><em>I<\/em><\/strong> &#8211; Interface Segregation Principle<\/p>\n<p>According to this principle, a class should not be forced to implement methods that it does not depend upon. A nice rule of thumb here is if you detect that you are making a dummy\/empty implementation of a method (like the increaseVolume in the ASilentMovie class in the previous example), you are breaking this principle. The purpose here is to have our classes have only the methods that they need to perform their jobs.<\/p>\n<p>Let&#8217;s continue with our previous movie example, but a bit refactored, to see this principle in action.<\/p>\n<div class=\"highlight js-code-highlight\">\n<pre class=\"highlight plaintext\"><code>public interface Movie{\n    public void play();\n    public void increaseVolume();\n}\n\npublic class Joker implements Movie{\n    public void play(){\n        \/\/implementation detail\n    }\n\n    public void increaseVolume(){\n        \/\/implementation detail\n    }\n}\n\npublic class ASilentMovie implements Movie{\n    public void play(){\n        \/\/implementation detail\n    }\n\n    public void increaseVolume(){\n        \/\/implementation detail [PROBLEM HERE]\n    }\n}\n<\/code><\/pre>\n<div class=\"highlight__panel js-actions-panel\">\n<div class=\"highlight__panel-action js-fullscreen-code-action\">\n    <svg xmlns=\"http:\/\/www.w3.org\/2000\/svg\" width=\"20px\" height=\"20px\" viewbox=\"0 0 24 24\" class=\"highlight-action crayons-icon highlight-action--fullscreen-on\"><title>Enter fullscreen mode<\/title>\n    <path d=\"M16 3h6v6h-2V5h-4V3zM2 3h6v2H4v4H2V3zm18 16v-4h2v6h-6v-2h4zM4 19h4v2H2v-6h2v4z\"\/>\n<\/svg><\/p>\n<p>    <svg xmlns=\"http:\/\/www.w3.org\/2000\/svg\" width=\"20px\" height=\"20px\" viewbox=\"0 0 24 24\" class=\"highlight-action crayons-icon highlight-action--fullscreen-off\"><title>Exit fullscreen mode<\/title>\n    <path d=\"M18 7h4v2h-6V3h2v4zM8 9H2V7h4V3h2v6zm10 8v4h-2v-6h6v2h-4zM8 15v6H6v-4H2v-2h6z\"\/>\n<\/svg><\/p>\n<\/div>\n<\/div>\n<\/div>\n<p>As we saw from the previous Movie example, there was a problem when we tried to increase the volume of a silent film. We were breaking the Liskov Substitution Principle. As you can now see, and as previously mentioned, we are also breaking the Interface Segregation principle, because the ASilentMovie class is depending(implementing) on a method that is not used.<\/p>\n<p>We can refactor this to comply with the Interface Segregation Principle, as follows.<\/p>\n<div class=\"highlight js-code-highlight\">\n<pre class=\"highlight plaintext\"><code>public interface MoviePlayManager{\n    public void play();\n}\n\npublic interface AudioManager{\n    public void increaseVolume();\n}\n\npublic class Joker implements MoviePlayManager,AudioManager{\n    public void play(){\n        \/\/implementation detail\n    }\n\n    public void increaseVolume(){\n        \/\/implementation detail\n    }\n}\n\npublic class ASilentMovie implements MoviePlayManager{\n    public void play(){\n        \/\/implementation detail\n    }\n}\n<\/code><\/pre>\n<div class=\"highlight__panel js-actions-panel\">\n<div class=\"highlight__panel-action js-fullscreen-code-action\">\n    <svg xmlns=\"http:\/\/www.w3.org\/2000\/svg\" width=\"20px\" height=\"20px\" viewbox=\"0 0 24 24\" class=\"highlight-action crayons-icon highlight-action--fullscreen-on\"><title>Enter fullscreen mode<\/title>\n    <path d=\"M16 3h6v6h-2V5h-4V3zM2 3h6v2H4v4H2V3zm18 16v-4h2v6h-6v-2h4zM4 19h4v2H2v-6h2v4z\"\/>\n<\/svg><\/p>\n<p>    <svg xmlns=\"http:\/\/www.w3.org\/2000\/svg\" width=\"20px\" height=\"20px\" viewbox=\"0 0 24 24\" class=\"highlight-action crayons-icon highlight-action--fullscreen-off\"><title>Exit fullscreen mode<\/title>\n    <path d=\"M18 7h4v2h-6V3h2v4zM8 9H2V7h4V3h2v6zm10 8v4h-2v-6h6v2h-4zM8 15v6H6v-4H2v-2h6z\"\/>\n<\/svg><\/p>\n<\/div>\n<\/div>\n<\/div>\n<p>As you can see, our ASilentMovie class only depends on the methods it actually uses!<\/p>\n<hr\/>\n<p><strong><em>D<\/em><\/strong> &#8211; Dependency Inversion Principle<\/p>\n<p>According to this principle, your classes should depend only on abstractions and not on particular implementations.<\/p>\n<p>This might be hard to visualize, but have the following code example in consideration.<\/p>\n<div class=\"highlight js-code-highlight\">\n<pre class=\"highlight plaintext\"><code>public class ComedyCategory{\n\n}\n\npublic class Movie{\n    private String name;\n    private ComedyCategory comedyCategory;\n\n    public Movie(String name, ComedyCategory comedyCategory){\n\n    }\n\n    public ComedyCategory getCategory(){\n        return this.comedyCategory;\n    }\n\n    public void setCategory(ComedyCategory comedyCategory){\n        this.comedyCategory = comedyCategory;\n    }\n}\n<\/code><\/pre>\n<div class=\"highlight__panel js-actions-panel\">\n<div class=\"highlight__panel-action js-fullscreen-code-action\">\n    <svg xmlns=\"http:\/\/www.w3.org\/2000\/svg\" width=\"20px\" height=\"20px\" viewbox=\"0 0 24 24\" class=\"highlight-action crayons-icon highlight-action--fullscreen-on\"><title>Enter fullscreen mode<\/title>\n    <path d=\"M16 3h6v6h-2V5h-4V3zM2 3h6v2H4v4H2V3zm18 16v-4h2v6h-6v-2h4zM4 19h4v2H2v-6h2v4z\"\/>\n<\/svg><\/p>\n<p>    <svg xmlns=\"http:\/\/www.w3.org\/2000\/svg\" width=\"20px\" height=\"20px\" viewbox=\"0 0 24 24\" class=\"highlight-action crayons-icon highlight-action--fullscreen-off\"><title>Exit fullscreen mode<\/title>\n    <path d=\"M18 7h4v2h-6V3h2v4zM8 9H2V7h4V3h2v6zm10 8v4h-2v-6h6v2h-4zM8 15v6H6v-4H2v-2h6z\"\/>\n<\/svg><\/p>\n<\/div>\n<\/div>\n<\/div>\n<p>Take a closer look at the movie class. It has two fields, which are the movie name and the movie category, which is a specific class with its own specificity and characteristics.<\/p>\n<p>What happens with the example I just gave you is that our movie class is depending on a specific implementation of a category (in this case the comedy category). With this, we are creating a tight coupling between our Movie class and the ComedeCategory class. We want to avoid these tight couplings.<\/p>\n<p>One way we can do this is by creating the abstraction\/interface of a category and having all existing categories inherit\/implement it.<\/p>\n<p>The following refactoring tries to show this in practice.<\/p>\n<div class=\"highlight js-code-highlight\">\n<pre class=\"highlight plaintext\"><code>public interface Category{\n\n}\n\npublic class ComedyCategory implements Category{\n\n}\n\npublic class Movie{\n    private String name;\n    private Category comedyCategory;\n\n    public Movie(String name, Category comedyCategory){\n\n    }\n\n    public ComedyCategory getCategory(){\n        return this.comedyCategory;\n    }\n\n    public void setCategory(Category comedyCategory){\n        this.comedyCategory = comedyCategory;\n    }\n}\n<\/code><\/pre>\n<div class=\"highlight__panel js-actions-panel\">\n<div class=\"highlight__panel-action js-fullscreen-code-action\">\n    <svg xmlns=\"http:\/\/www.w3.org\/2000\/svg\" width=\"20px\" height=\"20px\" viewbox=\"0 0 24 24\" class=\"highlight-action crayons-icon highlight-action--fullscreen-on\"><title>Enter fullscreen mode<\/title>\n    <path d=\"M16 3h6v6h-2V5h-4V3zM2 3h6v2H4v4H2V3zm18 16v-4h2v6h-6v-2h4zM4 19h4v2H2v-6h2v4z\"\/>\n<\/svg><\/p>\n<p>    <svg xmlns=\"http:\/\/www.w3.org\/2000\/svg\" width=\"20px\" height=\"20px\" viewbox=\"0 0 24 24\" class=\"highlight-action crayons-icon highlight-action--fullscreen-off\"><title>Exit fullscreen mode<\/title>\n    <path d=\"M18 7h4v2h-6V3h2v4zM8 9H2V7h4V3h2v6zm10 8v4h-2v-6h6v2h-4zM8 15v6H6v-4H2v-2h6z\"\/>\n<\/svg><\/p>\n<\/div>\n<\/div>\n<\/div>\n<p>As you can see, now our Movie class only depends on the abstraction of the category and not on a specific implementation of a category. What does this mean in practical terms?<\/p>\n<p>With our first approach, to instantiate the Movie class, we should have something like <code>Movie joker = new Movie(\"Joker\", new ComedyCategory())<\/code>. If we tried and did <code>Movie joker = new Movie(\"Joker\", new DramaCategory())<\/code>, we would get an error!<\/p>\n<p>With our refactored approach, either way would work (the second one would work if DramaCategory implemented Category, of course). We gain flexibility in which category to place our movie at. This flexibility, which can be more generalized in our projects, is one of the major advantages of obeying this principle. Another one is that our applications get more decoupled.<\/p>\n<p>\ud83d\ude01 <strong>I hope this has helped!<\/strong><\/p>\n<p>That&#8217;s everything for now! Thank you so much for reading. If you are more of a visual learner please refer to <a href=\"https:\/\/medium.com\/backticks-tildes\/the-s-o-l-i-d-principles-in-pictures-b34ce2f1e898\">this<\/a> amazing article, which explains the previous concepts in a more visual way!<\/p>\n<p>If you have any questions please feel free to drop them off. <br \/>Follow me if you want to read more about these kinds of topics!<\/p>\n<p><strong>Social Media Links<\/strong>:<br \/><a href=\"https:\/\/www.linkedin.com\/in\/rafaelcamara96\/\">LinkedIn<\/a><br \/><a href=\"https:\/\/twitter.com\/RafaJCamara\">Twitter<\/a><br \/><a href=\"https:\/\/github.com\/RafaelJCamara\">Github<\/a><\/p>\n<\/p><\/div>\n<p><script async src=\"\/\/platform.twitter.com\/widgets.js\" charset=\"utf-8\"><\/script><br \/>\n<br \/><\/p>\n","protected":false},"excerpt":{"rendered":"<p>The SOLID principles are a set of good practices of the Object-Oriented Design (OOD) world. We should have them in consideration when producing our software if we want it to be more easily scalable, maintainable, and extended. SOLID is an acronym, and each character of this acronym refers to an OOD principle, explained down below. &hellip;<\/p>\n<p class=\"read-more\"> <a class=\"\" href=\"http:\/\/localhost\/wordpress\/solid-principles-explained-dev-community\/\"> <span class=\"screen-reader-text\">SOLID principles explained &#8211; DEV Community<\/span> Read More &raquo;<\/a><\/p>\n","protected":false},"author":1,"featured_media":1535,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":{"site-sidebar-layout":"default","site-content-layout":"default","ast-main-header-display":"","ast-hfb-above-header-display":"","ast-hfb-below-header-display":"","ast-hfb-mobile-header-display":"","site-post-title":"","ast-breadcrumbs-content":"","ast-featured-img":"","footer-sml-layout":"","theme-transparent-header-meta":"","adv-header-id-meta":"","stick-header-meta":"","header-above-stick-meta":"","header-main-stick-meta":"","header-below-stick-meta":""},"categories":[1],"tags":[],"_links":{"self":[{"href":"http:\/\/localhost\/wordpress\/wp-json\/wp\/v2\/posts\/1534"}],"collection":[{"href":"http:\/\/localhost\/wordpress\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"http:\/\/localhost\/wordpress\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"http:\/\/localhost\/wordpress\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"http:\/\/localhost\/wordpress\/wp-json\/wp\/v2\/comments?post=1534"}],"version-history":[{"count":0,"href":"http:\/\/localhost\/wordpress\/wp-json\/wp\/v2\/posts\/1534\/revisions"}],"wp:featuredmedia":[{"embeddable":true,"href":"http:\/\/localhost\/wordpress\/wp-json\/wp\/v2\/media\/1535"}],"wp:attachment":[{"href":"http:\/\/localhost\/wordpress\/wp-json\/wp\/v2\/media?parent=1534"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"http:\/\/localhost\/wordpress\/wp-json\/wp\/v2\/categories?post=1534"},{"taxonomy":"post_tag","embeddable":true,"href":"http:\/\/localhost\/wordpress\/wp-json\/wp\/v2\/tags?post=1534"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}