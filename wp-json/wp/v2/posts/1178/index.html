{"id":1178,"date":"2022-03-09T17:17:34","date_gmt":"2022-03-09T17:17:34","guid":{"rendered":"http:\/\/localhost\/wordpress\/modern-web-frameworks-for-the-modern-cloud\/"},"modified":"2022-03-09T17:17:34","modified_gmt":"2022-03-09T17:17:34","slug":"modern-web-frameworks-for-the-modern-cloud","status":"publish","type":"post","link":"http:\/\/localhost\/wordpress\/modern-web-frameworks-for-the-modern-cloud\/","title":{"rendered":"Modern Web Frameworks for the Modern Cloud"},"content":{"rendered":"<p> <br \/>\n<\/p>\n<div data-article-id=\"1017382\" id=\"article-body\">\n<h2>\n  <a name=\"different-rendering-options\" href=\"#different-rendering-options\"><br \/>\n  <\/a><br \/>\n  Different rendering options<br \/>\n<\/h2>\n<p>It appears to me that making architectural decisions for Web development is more complicated than ever due to the emergence of frameworks that bake in client\/server tradeoffs. Yes, I am thinking of <a href=\"https:\/\/nextjs.org\/\">Next.js<\/a> or <a href=\"https:\/\/remix.run\/\">Remix<\/a>, which offer different rendering options for different use cases. In any case, there is a lot of information out there to help Web developers make informed decisions.<\/p>\n<p>Typically, Web developers solve these tradeoffs and pick one rendering method or another driven by a combination of data and user experience requirements:<\/p>\n<ul>\n<li>\n<p><strong>Static Site Generation (SSG)<\/strong>: Pages of your Web App \/ Web Site are generated at build time. It helps build sites when data is not changed or updated frequently, such as information portals or news sites. Frameworks like Next.js support features such as <a href=\"https:\/\/nextjs.org\/docs\/basic-features\/data-fetching\/incremental-static-regeneration\">Incremental Static Regeneration<\/a> which means that the static site is regenerated <strong>on the server<\/strong> automatically based on a schedule configured by developers.<\/p>\n<\/li>\n<li>\n<p><strong>Server-Side Rendering (SSR)<\/strong>: Content of your Web App \/ Web Site is generated dynamically on a request basis. This rendering solution is most appropriate for data-intensive scenarios where content is updated very frequently, it is very large, access latency is critical, or complex processing and transformation is needed before returning the response to the client.<\/p>\n<\/li>\n<li>\n<p><strong>Client-Side Rendering (CSR)<\/strong>: The data displayed on your Web App \/ Web Site is served through an HTTP API and rendered by the client on the browser. To improve the performance time at the client device, this data must be lightweight and ready to be consumed without further processing. This approach can help for those cases where user interactions and state management of the user interface need to happen as close to the user as possible to offer a very interactive and reactive user experience.<\/p>\n<\/li>\n<\/ul>\n<p>However, modern deployment options have additional non-functional requirements (NFRs). I am talking about NFRs such as an extra twist in performance, cost implications, and environmental impact. These are things that nowadays Web Developers need to consider when making these architectural decisions.<\/p>\n<h2>\n  <a name=\"the-battle-at-the-serverside\" href=\"#the-battle-at-the-serverside\"><br \/>\n  <\/a><br \/>\n  The battle at the server-side<br \/>\n<\/h2>\n<p>We now count on an extensive catalog of managed cloud services and pure serverless primitives. There is a battle in this server-side space between second-tier cloud platforms such as Vercel or Netlify (they don&#8217;t own Datacenters) and first-tier cloud ones such as Cloudflare and AWS (they own Datacenters). They all compete with each other to offer the best Web developer experience and optimize those new NFRs. <\/p>\n<p>Especially for first-tier cloud platform, this battle is making innovations spring at a pace we have never been before, especially with the emergence of <strong>Edge Computing<\/strong> solutions.<\/p>\n<p><a href=\"https:\/\/dev.to\/peibolsang\/the-future-of-cloud-computing-is-developer-experience-g0p\">As I wrote in the past<\/a>, computing at the edge is not about CDNs and caches anymore; this is something else. We are now talking about moving part of our applications and services to an edge location. An edge location is where cloud providers cache content so that it can be very quickly accessed by local referrers. It also allows local access to the cloud platform&#8217;s network backbone avoiding the public internet between the edge location and the regional datacenter from where content originates.<\/p>\n<p>At the edge, actual client requests and application logic can be processed and executed without the need to send that request to a service running on the origin cloud region. Of course, this approach still qualifies as serverless because you don&#8217;t need to provision or manage any type of runtime. Additionally, this approach comes with further benefits, such as global distribution and automatic multi-region access for your applications out of the box.<\/p>\n<h2>\n  <a name=\"edge-computing-use-cases\" href=\"#edge-computing-use-cases\"><br \/>\n  <\/a><br \/>\n  Edge Computing use cases<br \/>\n<\/h2>\n<p>Okay, then, how does edge computing help Web development? In my opinion, it can make it better, faster, and cheaper with solutions that help and support the Javascript development community. Solutions such as <a href=\"https:\/\/workers.cloudflare.com\/\">Cloudflare Workers<\/a> (or <a href=\"https:\/\/developers.cloudflare.com\/pages\/platform\/functions\">Cloudflare Page Functions<\/a>) are very confortable for Web developers as they offer the same native Javascript APIs that developers are used to work with in the browser. It&#8217;s a very natural ecosystem for them.<\/p>\n<p>In its current form, I would choose Edge Computing services only as an add-on layer on top of my server-side components running at the cloud origin for very concrete use cases:<\/p>\n<ol>\n<li>\n<strong>Data Filtering<\/strong>: Filter data coming from the application components before sending a response to the client. This can be done based on user-specific criteria such as location or device type. The goal is to avoid data processing and filtering as much as possible at the browser, so it can receive ready-to-render data.<\/li>\n<li>\n<strong>Stateful Requests<\/strong>: Combined with lightweight storage at the edge (e.g., Key-Value stores), we could handle sophisticated states on edge on top of the application running on a serverless environment. And we could do it without firing full round trips to the cloud origin region. This would allow Web developers to build session-based online collaboration tools (e.g., Miro dashboard) running on serverless computing.<\/li>\n<li>\n<strong>Authorization<\/strong>: Apply Role Based Access Control rules to UI components returned to the client. Imagine you are including an Admin section in your UI which options are affected by the user&#8217;s role. Filtering those UI options at the edge would be a very cost-effective and high-performant solution.<\/li>\n<li>\n<strong>Cyber-protection<\/strong>: Use native cybersecurity features and APIs at the CDN to identify networking patterns such as bot detection and apply URL redirects to avoid exposing the application code running at cloud region to malicious agents. Also, I&#8217;ve seen edge functions used to prevent <em>clickjacking<\/em> or <em>XSS<\/em> attacks by <a href=\"https:\/\/docs.aws.amazon.com\/AmazonCloudFront\/latest\/DeveloperGuide\/example-function-add-security-headers.html\">adding security headers to the response<\/a>.<\/li>\n<li>\n<strong>Performance<\/strong>: Remember that edge computing providers own cache datacenters all over the world, so I am sure there is one close to your location right now. This allow them implement powerful caching mechanisms to improve TTFB for static content (HTML, CSS, Javascript bundles) and other techniques such as image resizing optimization based on user devices. <\/li>\n<\/ol>\n<h2>\n  <a name=\"conclusion\" href=\"#conclusion\"><br \/>\n  <\/a><br \/>\n  Conclusion<br \/>\n<\/h2>\n<p>These use cases can be game-changing especially for Javascript developers building Web applications. Solutions like Cloudflare Workers are based on <a href=\"https:\/\/v8.dev\/\">Google&#8217;s V8 engine<\/a> allowing response times for client requests under 50ms (i.e., full round-trip, not just internal execution time). Then, as described above, the main logic for the server-side components would run entirely on the cloud region, with a preference for serverless components. But who knows, maybe edge computing evolves to the point where we can run larger pieces of business logic closer to the user location.<\/p>\n<p>I am getting my hands dirty with a few of Cloudflare&#8217;s solutions right now, so in my next post I will cover in detail a few of their most compelling edge computing services. Follow me on <a href=\"https:\/\/twitter.com\/peibolsang\">Twitter<\/a> to keep the conversation going!<\/p>\n<p><em>(Cover photo credits: Alan Tang via Unsplash)<\/em><\/p>\n<\/p><\/div>\n<p><script async src=\"\/\/platform.twitter.com\/widgets.js\" charset=\"utf-8\"><\/script><br \/>\n<br \/><\/p>\n","protected":false},"excerpt":{"rendered":"<p>Different rendering options It appears to me that making architectural decisions for Web development is more complicated than ever due to the emergence of frameworks that bake in client\/server tradeoffs. Yes, I am thinking of Next.js or Remix, which offer different rendering options for different use cases. In any case, there is a lot of &hellip;<\/p>\n<p class=\"read-more\"> <a class=\"\" href=\"http:\/\/localhost\/wordpress\/modern-web-frameworks-for-the-modern-cloud\/\"> <span class=\"screen-reader-text\">Modern Web Frameworks for the Modern Cloud<\/span> Read More &raquo;<\/a><\/p>\n","protected":false},"author":1,"featured_media":1179,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":{"site-sidebar-layout":"default","site-content-layout":"default","ast-main-header-display":"","ast-hfb-above-header-display":"","ast-hfb-below-header-display":"","ast-hfb-mobile-header-display":"","site-post-title":"","ast-breadcrumbs-content":"","ast-featured-img":"","footer-sml-layout":"","theme-transparent-header-meta":"","adv-header-id-meta":"","stick-header-meta":"","header-above-stick-meta":"","header-main-stick-meta":"","header-below-stick-meta":""},"categories":[1],"tags":[],"_links":{"self":[{"href":"http:\/\/localhost\/wordpress\/wp-json\/wp\/v2\/posts\/1178"}],"collection":[{"href":"http:\/\/localhost\/wordpress\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"http:\/\/localhost\/wordpress\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"http:\/\/localhost\/wordpress\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"http:\/\/localhost\/wordpress\/wp-json\/wp\/v2\/comments?post=1178"}],"version-history":[{"count":0,"href":"http:\/\/localhost\/wordpress\/wp-json\/wp\/v2\/posts\/1178\/revisions"}],"wp:featuredmedia":[{"embeddable":true,"href":"http:\/\/localhost\/wordpress\/wp-json\/wp\/v2\/media\/1179"}],"wp:attachment":[{"href":"http:\/\/localhost\/wordpress\/wp-json\/wp\/v2\/media?parent=1178"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"http:\/\/localhost\/wordpress\/wp-json\/wp\/v2\/categories?post=1178"},{"taxonomy":"post_tag","embeddable":true,"href":"http:\/\/localhost\/wordpress\/wp-json\/wp\/v2\/tags?post=1178"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}