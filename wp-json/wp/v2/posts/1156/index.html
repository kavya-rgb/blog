{"id":1156,"date":"2022-03-09T17:10:41","date_gmt":"2022-03-09T17:10:41","guid":{"rendered":"http:\/\/localhost\/wordpress\/the-importance-of-proper-serverless-api-design\/"},"modified":"2022-03-09T17:10:41","modified_gmt":"2022-03-09T17:10:41","slug":"the-importance-of-proper-serverless-api-design","status":"publish","type":"post","link":"http:\/\/localhost\/wordpress\/the-importance-of-proper-serverless-api-design\/","title":{"rendered":"The Importance of Proper Serverless API Design"},"content":{"rendered":"<p> <br \/>\n<\/p>\n<div data-article-id=\"1017298\" id=\"article-body\">\n<p>I was troubleshooting a production issue last week. The issue stated that some shared files weren&#8217;t showing up in our application even though they had been shared multiple times.<\/p>\n<p>Seems like a simple enough bug to triage.<\/p>\n<p>I went to CloudWatch to peek at the logs for the lambda that was responsible for sharing files. But there were no errors. Everything seemed to be succeeding without issue.<\/p>\n<p>So I took a look at some of the files that were &#8220;missing&#8221; in DynamoDB to see if they were in a weird status. Once again, everything seemed to be in place. It made sense why there weren&#8217;t any errors in the logs, the data all looked right.<\/p>\n<p>I tried to reproduce it myself. I started over from scratch, but everything seemed fine again. It all showed up for me fine. So I went to the area reported in the bug and sure enough, files were missing.<\/p>\n<p><em>What the heck was going on?<\/em><\/p>\n<p>I spent a lot of time looking at the same 100 lines of code in that lambda file. Just staring at it. Walking through it in my head trying to figure out where it could possibly be going wrong.<\/p>\n<p>Then I hit a turning point. I compared the area with the reported issue to the one I tried to reproduce and something stuck out to me. I had only shared 7 or 8 files, but the one reported in the issue had shared 2,000. <em>This had to be a data size issue<\/em>.<\/p>\n<p>Back in the code I see when we&#8217;re querying for data we load <em>everything<\/em>. All files, related entities, the works. But we don&#8217;t page. DynamoDB can <a href=\"https:\/\/docs.aws.amazon.com\/amazondynamodb\/latest\/developerguide\/Query.html\">retrieve a max of 1 MB of data<\/a> in a single query. This was my problem.<\/p>\n<p>When DynamoDB has more results than the 1 MB limit, it returns a <code>LastEvaluatedKey<\/code> in the response so you can run subsequent queries starting where it left off. <\/p>\n<p>The code was ignoring that. It never occurred to me that a user would have this much data in production. So I took a step back to think about what we had built and where it went wrong.<\/p>\n<p>It all came down to poor REST API design and bad NoSQL data modeling.<\/p>\n<h2>\n  <a name=\"separate-your-entities\" href=\"#separate-your-entities\"><br \/>\n  <\/a><br \/>\n  Separate Your Entities<br \/>\n<\/h2>\n<p>A great aspect of REST is that it allows intuitive drill-down into your entities. If an entity has children, you should have an endpoint to load the entity and an endpoint to load the children. If the children have children, you&#8217;d have an endpoint to load the children&#8217;s children (and so on). Let&#8217;s say we had the entity model described below:<\/p>\n<p><a href=\"https:\/\/res.cloudinary.com\/practicaldev\/image\/fetch\/s--c9QXPUEl--\/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\/https:\/\/dev-to-uploads.s3.amazonaws.com\/uploads\/articles\/j6bmv0wao69fzvvh8tdl.png\" class=\"article-body-image-wrapper\"><img src=\"https:\/\/res.cloudinary.com\/practicaldev\/image\/fetch\/s--c9QXPUEl--\/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\/https:\/\/dev-to-uploads.s3.amazonaws.com\/uploads\/articles\/j6bmv0wao69fzvvh8tdl.png\" alt=\"Entity Relationship Diagram for a neighborhood\" loading=\"lazy\" width=\"716\" height=\"692\"\/><\/a><\/p>\n<p><em>Entity Relationship Diagram (ERD) for a neighborhood<\/em><\/p>\n<p>This view shows a 4 level hierarchy of entities, where <em>neighborhood<\/em> is on top and it has two child entities <em>property<\/em> and <em>HOA (Home Owners Association)<\/em>. When it comes to RESTful API design, endpoints would be structured like this:<\/p>\n<div class=\"highlight js-code-highlight\">\n<pre class=\"highlight plaintext\"><code>\/neighborhoods\/{neighborhoodId}\n\/neighborhoods\/{neighborhoodId}\/properties\n\/neighborhoods\/{neighborhoodId}\/hoa\n<\/code><\/pre>\n<div class=\"highlight__panel js-actions-panel\">\n<div class=\"highlight__panel-action js-fullscreen-code-action\">\n    <svg xmlns=\"http:\/\/www.w3.org\/2000\/svg\" width=\"20px\" height=\"20px\" viewbox=\"0 0 24 24\" class=\"highlight-action crayons-icon highlight-action--fullscreen-on\"><title>Enter fullscreen mode<\/title>\n    <path d=\"M16 3h6v6h-2V5h-4V3zM2 3h6v2H4v4H2V3zm18 16v-4h2v6h-6v-2h4zM4 19h4v2H2v-6h2v4z\"\/>\n<\/svg><\/p>\n<p>    <svg xmlns=\"http:\/\/www.w3.org\/2000\/svg\" width=\"20px\" height=\"20px\" viewbox=\"0 0 24 24\" class=\"highlight-action crayons-icon highlight-action--fullscreen-off\"><title>Exit fullscreen mode<\/title>\n    <path d=\"M18 7h4v2h-6V3h2v4zM8 9H2V7h4V3h2v6zm10 8v4h-2v-6h6v2h-4zM8 15v6H6v-4H2v-2h6z\"\/>\n<\/svg><\/p>\n<\/div>\n<\/div>\n<\/div>\n<p>The endpoint structure is to start at the top of the hierarchy and add a path for each layer you traverse.<\/p>\n<p>In our next layer, the <em>property<\/em> entity has two child entities, <em>trees<\/em> and <em>buildings<\/em>. We would structure these to be:<\/p>\n<div class=\"highlight js-code-highlight\">\n<pre class=\"highlight plaintext\"><code>\/neighborhoods\/{neighborhoodId}\/properties\/{propertyId}\/trees\n\/neighborhoods\/{neighborhoodId}\/properties\/{propertyId}\/buildings\n<\/code><\/pre>\n<div class=\"highlight__panel js-actions-panel\">\n<div class=\"highlight__panel-action js-fullscreen-code-action\">\n    <svg xmlns=\"http:\/\/www.w3.org\/2000\/svg\" width=\"20px\" height=\"20px\" viewbox=\"0 0 24 24\" class=\"highlight-action crayons-icon highlight-action--fullscreen-on\"><title>Enter fullscreen mode<\/title>\n    <path d=\"M16 3h6v6h-2V5h-4V3zM2 3h6v2H4v4H2V3zm18 16v-4h2v6h-6v-2h4zM4 19h4v2H2v-6h2v4z\"\/>\n<\/svg><\/p>\n<p>    <svg xmlns=\"http:\/\/www.w3.org\/2000\/svg\" width=\"20px\" height=\"20px\" viewbox=\"0 0 24 24\" class=\"highlight-action crayons-icon highlight-action--fullscreen-off\"><title>Exit fullscreen mode<\/title>\n    <path d=\"M18 7h4v2h-6V3h2v4zM8 9H2V7h4V3h2v6zm10 8v4h-2v-6h6v2h-4zM8 15v6H6v-4H2v-2h6z\"\/>\n<\/svg><\/p>\n<\/div>\n<\/div>\n<\/div>\n<p>We can see that <em>buildings<\/em> has a child entity named <em>rooms<\/em>. So we&#8217;d structure those endpoints as :<\/p>\n<div class=\"highlight js-code-highlight\">\n<pre class=\"highlight plaintext\"><code>\/neighborhoods\/{neighborhoodId}\/properties\/{propertyId}\/buildings\/{buildingId}\/rooms\n\/neighborhoods\/{neighborhoodId}\/properties\/{propertyId}\/buildings\/{buildingId}\/rooms\/{roomId}\n<\/code><\/pre>\n<div class=\"highlight__panel js-actions-panel\">\n<div class=\"highlight__panel-action js-fullscreen-code-action\">\n    <svg xmlns=\"http:\/\/www.w3.org\/2000\/svg\" width=\"20px\" height=\"20px\" viewbox=\"0 0 24 24\" class=\"highlight-action crayons-icon highlight-action--fullscreen-on\"><title>Enter fullscreen mode<\/title>\n    <path d=\"M16 3h6v6h-2V5h-4V3zM2 3h6v2H4v4H2V3zm18 16v-4h2v6h-6v-2h4zM4 19h4v2H2v-6h2v4z\"\/>\n<\/svg><\/p>\n<p>    <svg xmlns=\"http:\/\/www.w3.org\/2000\/svg\" width=\"20px\" height=\"20px\" viewbox=\"0 0 24 24\" class=\"highlight-action crayons-icon highlight-action--fullscreen-off\"><title>Exit fullscreen mode<\/title>\n    <path d=\"M18 7h4v2h-6V3h2v4zM8 9H2V7h4V3h2v6zm10 8v4h-2v-6h6v2h-4zM8 15v6H6v-4H2v-2h6z\"\/>\n<\/svg><\/p>\n<\/div>\n<\/div>\n<\/div>\n<p>Each one of the endpoints listed above would return the last entity listed in the url (assuming these were all <strong>GET<\/strong> endpoints). <\/p>\n<ul>\n<li>\n<code>\/neighborhoods\/{neighboorhoodId}<\/code> returns data about the <em>neighborhood<\/em> entity<\/li>\n<li>\n<code>\/neighborhoods\/{neighborhoodId}\/properties\/{propertyId}<\/code> returns data about a specific <em>property<\/em> entity<\/li>\n<li>\n<code>\/neighborhoods\/{neighborhoodId}\/properties\/{propertyId}\/buildings\/{buildingId}\/rooms<\/code> returns a list of all <em>rooms<\/em> in a specific <em>building<\/em>\n<\/li>\n<\/ul>\n<p>Structuring your data and endpoints in this fashion is not only an <a href=\"https:\/\/restfulapi.net\/rest-api-design-tutorial-with-example\/\">industry-standard way to implement REST<\/a>, but it&#8217;s a way to help you identify and design your <a href=\"https:\/\/docs.aws.amazon.com\/prescriptive-guidance\/latest\/dynamodb-data-modeling\/step3.html\">NoSQL access patterns<\/a>.<\/p>\n<p>If you made the <code>\/neighborhoods\/{neighborhoodId}<\/code> endpoint return details on the <em>neighborhood<\/em>, <em>properties<\/em>, <em>HOA<\/em>, <em>trees<\/em>, <em>buildings<\/em>, and <em>rooms<\/em>, you would have a <strong>massive<\/strong> API call that drastically <a href=\"https:\/\/www.howtographql.com\/basics\/1-graphql-is-the-better-rest\/#:~:text=Overfetching%20means%20that%20a%20client,JSON%20array%20with%20user%20data.\">over fetches<\/a> data and would charge you way too much money to make database calls to DynamoDB.<\/p>\n<h2>\n  <a name=\"single-and-multientity-nosql-design\" href=\"#single-and-multientity-nosql-design\"><br \/>\n  <\/a><br \/>\n  Single and Multi-Entity NoSQL design<br \/>\n<\/h2>\n<p>If you adhere to REST standards, you should always have an easy way to <em>get a list of entities<\/em> and <em>get a single entity by id<\/em>. <\/p>\n<p>With DynamoDB, you can to take the drill down approach with <em><a href=\"https:\/\/aws.amazon.com\/blogs\/database\/choosing-the-right-dynamodb-partition-key\">composite keys<\/a><\/em>. This means you can structure your hash and range keys to include multiple entities in order to query your lists or get a single entity. <\/p>\n<p>For example, I might structure my hash and range key like this for a property:<\/p>\n<div class=\"highlight js-code-highlight\">\n<pre class=\"highlight plaintext\"><code>pk: `${neighborhoodId}#${propertyId}`,\nsk: `metadata`\n<\/code><\/pre>\n<div class=\"highlight__panel js-actions-panel\">\n<div class=\"highlight__panel-action js-fullscreen-code-action\">\n    <svg xmlns=\"http:\/\/www.w3.org\/2000\/svg\" width=\"20px\" height=\"20px\" viewbox=\"0 0 24 24\" class=\"highlight-action crayons-icon highlight-action--fullscreen-on\"><title>Enter fullscreen mode<\/title>\n    <path d=\"M16 3h6v6h-2V5h-4V3zM2 3h6v2H4v4H2V3zm18 16v-4h2v6h-6v-2h4zM4 19h4v2H2v-6h2v4z\"\/>\n<\/svg><\/p>\n<p>    <svg xmlns=\"http:\/\/www.w3.org\/2000\/svg\" width=\"20px\" height=\"20px\" viewbox=\"0 0 24 24\" class=\"highlight-action crayons-icon highlight-action--fullscreen-off\"><title>Exit fullscreen mode<\/title>\n    <path d=\"M18 7h4v2h-6V3h2v4zM8 9H2V7h4V3h2v6zm10 8v4h-2v-6h6v2h-4zM8 15v6H6v-4H2v-2h6z\"\/>\n<\/svg><\/p>\n<\/div>\n<\/div>\n<\/div>\n<p>And I could <em>overload<\/em> the sort\/range key like this:<\/p>\n<div class=\"highlight js-code-highlight\">\n<pre class=\"highlight plaintext\"><code>pk: `${neighborhoodId}#${propertyId}`,\nsk: `building#${buildingId}`\n<\/code><\/pre>\n<div class=\"highlight__panel js-actions-panel\">\n<div class=\"highlight__panel-action js-fullscreen-code-action\">\n    <svg xmlns=\"http:\/\/www.w3.org\/2000\/svg\" width=\"20px\" height=\"20px\" viewbox=\"0 0 24 24\" class=\"highlight-action crayons-icon highlight-action--fullscreen-on\"><title>Enter fullscreen mode<\/title>\n    <path d=\"M16 3h6v6h-2V5h-4V3zM2 3h6v2H4v4H2V3zm18 16v-4h2v6h-6v-2h4zM4 19h4v2H2v-6h2v4z\"\/>\n<\/svg><\/p>\n<p>    <svg xmlns=\"http:\/\/www.w3.org\/2000\/svg\" width=\"20px\" height=\"20px\" viewbox=\"0 0 24 24\" class=\"highlight-action crayons-icon highlight-action--fullscreen-off\"><title>Exit fullscreen mode<\/title>\n    <path d=\"M18 7h4v2h-6V3h2v4zM8 9H2V7h4V3h2v6zm10 8v4h-2v-6h6v2h-4zM8 15v6H6v-4H2v-2h6z\"\/>\n<\/svg><\/p>\n<\/div>\n<\/div>\n<\/div>\n<p>So if I wanted to get details on the <em>property<\/em>, I could do a <code>GetItem<\/code> with the first pk\/sk combo. If I wanted to get a list of <em>buildings<\/em> on that property, I could use the same pk, but do a query where <code>begins_with(sk, 'building#')<\/code>. If I wanted to get details about a specific building, I could do a <code>GetItem<\/code> with the pk\/sk for the building.<\/p>\n<p>What you want to avoid is building a structure that requires a <a href=\"https:\/\/docs.aws.amazon.com\/amazondynamodb\/latest\/APIReference\/API_Query.html#DDB-Query-request-FilterExpression\">FilterExpression<\/a> to find the data you want. A <em>FilterExpression<\/em> is applied after the query, which means you get charged for all the <a href=\"https:\/\/docs.aws.amazon.com\/amazondynamodb\/latest\/developerguide\/HowItWorks.ReadWriteCapacityMode.html#HowItWorks.requests\">Read Capactiy Units (RCUs)<\/a>. <\/p>\n<p>Serverless is all about pay for what you use, and you don&#8217;t want to unnecessarily be paying for reads that you are never going to use. If you find yourself in a situation where you might be overusing <em>FilterExpression<\/em>, take a step back and see if you can approach your data model differently.<\/p>\n<p>The bug I was working ran into this. We had an improperly designed data model around the shared files that was causing us to do a combination of <em>FilterExpressions<\/em> and post-query filtering. It was some serious overfetching! <\/p>\n<p>Due to this, we quickly ran into the issue (that was overlooked for so long) where DynamoDB was returning the <em>LastEvaluatedKey<\/em> to inform us there was more data to be loaded. But because we hadn&#8217;t anticipated data of this magnitude, our code wasn&#8217;t checking for that in the response. This caused us to not process all of the entities and give the appearance that files were missing.<\/p>\n<p>All of this could have been avoided if we had designed the data model correctly.<\/p>\n<h2>\n  <a name=\"plan-for-high-volume-actions\" href=\"#plan-for-high-volume-actions\"><br \/>\n  <\/a><br \/>\n  Plan For High Volume Actions<br \/>\n<\/h2>\n<p>With proper REST design, your endpoints should be a string of nouns. They offer an easy way to get at a hierarchy of elements. But what about scenarios where your application is going to be updating hundreds (or thousands) of entities at the same time?<\/p>\n<p>You could require a single API call for each entity update. Serverless APIs can absolutely scale to meet demand. <em>But should it<\/em>? If a single user is taking an action that results in 1000 API calls, what happens if 10 users are doing that at the same time? What about 100 users?<\/p>\n<p>You will quickly run into some <a href=\"https:\/\/docs.aws.amazon.com\/lambda\/latest\/dg\/gettingstarted-limits.html\">service limits<\/a> with concurrent lambda executions. You can always increase those limits, but again, <em>should you<\/em>?<\/p>\n<blockquote>\n<p>It&#8217;s ok to break the rules sometimes. Don&#8217;t be a fundamentalist.<\/p>\n<\/blockquote>\n<p>In scenarios like this where a single user is trying to update hundreds or thousands of entities at the same time, it might be time for a <strong>batch action endpoint<\/strong>. A <a href=\"https:\/\/www.mscharhag.com\/api-design\/bulk-and-batch-operations\">batch action endpoint<\/a> can be debated whether or not it is RESTful, but in some situations it&#8217;s absolutely necessary.<\/p>\n<p>If we&#8217;re trying to update 1000 entities, it might be better to make that 10 calls of 100 instead of 1000 calls of 1. This will keep your concurrent lambda counts down and help avoid bottlenecking. <\/p>\n<p>For high throughput endpoints, another alternative would be to integrate directly from API Gateway to SQS so you can control batch sizes and <a href=\"https:\/\/docs.aws.amazon.com\/AWSCloudFormation\/latest\/UserGuide\/aws-resource-lambda-function.html#cfn-lambda-function-reservedconcurrentexecutions\">limit concurrent executions<\/a> of the lambda function that is reading from the queue.<\/p>\n<h2>\n  <a name=\"its-never-too-late\" href=\"#its-never-too-late\"><br \/>\n  <\/a><br \/>\n  It&#8217;s Never Too Late<br \/>\n<\/h2>\n<p>If you find yourself not knowing the access patterns or high traffic endpoints when you begin your project, that&#8217;s ok! Work with what you know and what you anticipate to be the primary use case. <\/p>\n<p>There are ways to get insight before you&#8217;re done. Alberto Savoia&#8217;s <a href=\"https:\/\/www.pretotyping.org\/\">&#8220;The Right It&#8221; book<\/a> talks about strategies you can take to mitigate risk and do your designing up front.<\/p>\n<p>In the event that you&#8217;ve already built your software and you&#8217;re beginning to run into issues like I was, <em>it&#8217;s never too late to fix the problem<\/em>. You can build new endpoints, modify existing ones, or deprecate some that should no longer be used. Just be sure you aren&#8217;t creating <a href=\"https:\/\/blog.postman.com\/how-to-catch-breaking-changes-before-they-happen\/\">breaking changes<\/a> if your app is in production.<\/p>\n<p>You can redesign a data model. Migrating between serverless data models comes in five steps:<\/p>\n<ol>\n<li>\n<strong>Design<\/strong> &#8211; develop your data model with your known\/anticipated access patterns in mind<\/li>\n<li>\n<strong>Add<\/strong> &#8211; Add the new data model to your lambdas side by side with your old data model<\/li>\n<li>\n<strong>Convert<\/strong> &#8211; Create a lambda to convert your old data model to your new data model (be sure to keep the old entities in case something goes wrong!)<\/li>\n<li>\n<strong>Move<\/strong> &#8211; Update your user interface or integrations to use your new endpoints or versions or query string parameters that access your new data model<\/li>\n<li>\n<strong>Remove<\/strong> &#8211; After everything has been migrated, remove the code backing the old data model. You can remove the old data as well<\/li>\n<\/ol>\n<p>This approach applies specifically to applications following a <a href=\"https:\/\/dev.to\/allenheltondev\/are-you-really-ready-for-ci-cd-321h\">CI\/CD approach<\/a>. You have to make sure your migration is successful without any downtime as you make changes piece by piece.<\/p>\n<p>Use metrics to determine your most called endpoints. Are any running with significantly more concurrent executions than others? Is it the same user making a significant amount of calls? You can gain <a href=\"https:\/\/docs.aws.amazon.com\/lambda\/latest\/dg\/monitoring-insights.html\">incredibly valuable insights<\/a> for your lambda functions that let you pick out the outliers and candidates for a batch action.<\/p>\n<p>Software, especially serverless software, should be in a <a href=\"https:\/\/dev.to\/allenheltondev\/how-to-refactor-serverless-applications-the-right-way-44o3\">constant state of refactor<\/a>. You gain insights to how your application is being used every day, you add features, you debug problems. Every one of these things is a learning opportunity to improving your application. <\/p>\n<blockquote>\n<p>You will never know less than you do right now.<\/p>\n<\/blockquote>\n<p>Take the insights to improve your data models, optimize for performance and cost, and give your users a <a href=\"https:\/\/www.readysetcloud.io\/blog\/allen.helton\/design-to-delight-raising-the-bar-on-software-design-a1eec234188b\">delightful experience<\/a>.<\/p>\n<p>Happy coding!<\/p>\n<\/p><\/div>\n\n","protected":false},"excerpt":{"rendered":"<p>I was troubleshooting a production issue last week. The issue stated that some shared files weren&#8217;t showing up in our application even though they had been shared multiple times. Seems like a simple enough bug to triage. I went to CloudWatch to peek at the logs for the lambda that was responsible for sharing files. &hellip;<\/p>\n<p class=\"read-more\"> <a class=\"\" href=\"http:\/\/localhost\/wordpress\/the-importance-of-proper-serverless-api-design\/\"> <span class=\"screen-reader-text\">The Importance of Proper Serverless API Design<\/span> Read More &raquo;<\/a><\/p>\n","protected":false},"author":1,"featured_media":1157,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":{"site-sidebar-layout":"default","site-content-layout":"default","ast-main-header-display":"","ast-hfb-above-header-display":"","ast-hfb-below-header-display":"","ast-hfb-mobile-header-display":"","site-post-title":"","ast-breadcrumbs-content":"","ast-featured-img":"","footer-sml-layout":"","theme-transparent-header-meta":"","adv-header-id-meta":"","stick-header-meta":"","header-above-stick-meta":"","header-main-stick-meta":"","header-below-stick-meta":""},"categories":[1],"tags":[],"_links":{"self":[{"href":"http:\/\/localhost\/wordpress\/wp-json\/wp\/v2\/posts\/1156"}],"collection":[{"href":"http:\/\/localhost\/wordpress\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"http:\/\/localhost\/wordpress\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"http:\/\/localhost\/wordpress\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"http:\/\/localhost\/wordpress\/wp-json\/wp\/v2\/comments?post=1156"}],"version-history":[{"count":0,"href":"http:\/\/localhost\/wordpress\/wp-json\/wp\/v2\/posts\/1156\/revisions"}],"wp:featuredmedia":[{"embeddable":true,"href":"http:\/\/localhost\/wordpress\/wp-json\/wp\/v2\/media\/1157"}],"wp:attachment":[{"href":"http:\/\/localhost\/wordpress\/wp-json\/wp\/v2\/media?parent=1156"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"http:\/\/localhost\/wordpress\/wp-json\/wp\/v2\/categories?post=1156"},{"taxonomy":"post_tag","embeddable":true,"href":"http:\/\/localhost\/wordpress\/wp-json\/wp\/v2\/tags?post=1156"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}